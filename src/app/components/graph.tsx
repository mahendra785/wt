"use client";

import { useEffect, useRef, useState } from "react";
import * as d3 from "d3";

// Define types for our data
interface Node {
  id: number;
  name: string;
  category: string;
  path?: string;
  color?: string;
  content?: string; // Added content field for code explanation
}

interface Link {
  source: number;
  target: number;
  relation: string;
  strength?: number;
}

interface GraphData {
  nodes: Node[];
  links: Link[];
}

const initialGraphData: GraphData = {
  nodes: [
    // Root layout and page
    {
      id: 1,
      name: "layout.tsx",
      category: "layout",
      path: "app/",
      color: "#3182CE",
      content: `// Root layout for the application
  import { Inter } from 'next/font/google'
  import './globals.css'
  import Navbar from '@/components/Navbar'
  import Footer from '@/components/Footer'
  
  const inter = Inter({ subsets: ['latin'] })
  
  export const metadata = {
    title: 'My Next.js App',
    description: 'Generated by create next app',
  }
  
  export default function RootLayout({
    children,
  }: {
    children: React.ReactNode
  }) {
    return (
      <html lang="en">
        <body className={inter.className}>
          <Navbar />
          <main className="container mx-auto px-4 py-8">
            {children}
          </main>
          <Footer />
        </body>
      </html>
    )
  }`,
      dependencies: ["Navbar", "Footer", "globals.css"],
    },
    {
      id: 2,
      name: "page.tsx",
      category: "page",
      path: "app/",
      color: "#3182CE",
      content: `// Home page component
  import { Button } from '@/components/ui/Button'
  import { Card } from '@/components/ui/Card'
  import { getFeaturedPosts } from '@/lib/api'
  
  export default async function Home() {
    const posts = await getFeaturedPosts()
    
    return (
      <div>
        <h1 className="text-3xl font-bold mb-6">Featured Posts</h1>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {posts.map(post => (
            <Card key={post.id}>
              <h2 className="text-xl font-semibold">{post.title}</h2>
              <p className="text-gray-600 mt-2">{post.excerpt}</p>
              <Button href={\`/blog/\${post.slug}\`} className="mt-4">
                Read more
              </Button>
            </Card>
          ))}
        </div>
      </div>
    )
  }`,
      dependencies: ["Button", "Card", "getFeaturedPosts"],
    },

    // Blog pages
    {
      id: 3,
      name: "page.tsx",
      category: "page",
      path: "app/blog/",
      color: "#3182CE",
      content: `// Blog index page
  import { BlogList } from '@/components/blog/BlogList'
  import { getAllPosts } from '@/lib/api'
  
  export default async function BlogPage() {
    const posts = await getAllPosts()
    
    return (
      <div>
        <h1 className="text-3xl font-bold mb-8">Blog</h1>
        <BlogList posts={posts} />
      </div>
    )
  }`,
      dependencies: ["BlogList", "getAllPosts"],
    },
    {
      id: 4,
      name: "page.tsx",
      category: "page",
      path: "app/blog/[slug]/",
      color: "#3182CE",
      content: `// Single blog post page
  import { notFound } from 'next/navigation'
  import { PostContent } from '@/components/blog/PostContent'
  import { CommentForm } from '@/components/blog/CommentForm'
  import { getPostBySlug } from '@/lib/api'
  
  export default async function BlogPostPage({
    params,
  }: {
    params: { slug: string }
  }) {
    const post = await getPostBySlug(params.slug)
    
    if (!post) {
      notFound()
    }
  
    return (
      <article className="max-w-3xl mx-auto">
        <PostContent post={post} />
        <CommentForm postId={post.id} />
      </article>
    )
  }`,
      dependencies: ["PostContent", "CommentForm", "getPostBySlug"],
    },

    // API routes
    {
      id: 5,
      name: "route.ts",
      category: "api",
      path: "app/api/posts/",
      color: "#DD6B20",
      content: `// API route for posts
  import { NextResponse } from 'next/server'
  import { db } from '@/lib/db'
  import { validatePostInput } from '@/lib/validators'
  
  export async function GET() {
    try {
      const posts = await db.post.findMany({
        include: { author: true },
        orderBy: { createdAt: 'desc' }
      })
      return NextResponse.json(posts)
    } catch (error) {
      return NextResponse.json(
        { error: 'Failed to fetch posts' },
        { status: 500 }
      )
    }
  }
  
  export async function POST(request: Request) {
    try {
      const data = await request.json()
      const validation = validatePostInput(data)
      
      if (!validation.success) {
        return NextResponse.json(
          { error: validation.error },
          { status: 400 }
        )
      }
  
      const post = await db.post.create({
        data: validation.data
      })
  
      return NextResponse.json(post, { status: 201 })
    } catch (error) {
      return NextResponse.json(
        { error: 'Failed to create post' },
        { status: 500 }
      )
    }
  }`,
      dependencies: ["db", "validatePostInput"],
    },
    {
      id: 6,
      name: "route.ts",
      category: "api",
      path: "app/api/comments/",
      color: "#DD6B20",
      content: `// API route for comments
  import { NextResponse } from 'next/server'
  import { db } from '@/lib/db'
  import { validateCommentInput } from '@/lib/validators'
  
  export async function GET(request: Request) {
    const { searchParams } = new URL(request.url)
    const postId = searchParams.get('postId')
  
    try {
      const comments = await db.comment.findMany({
        where: { postId: postId || undefined },
        orderBy: { createdAt: 'desc' }
      })
      return NextResponse.json(comments)
    } catch (error) {
      return NextResponse.json(
        { error: 'Failed to fetch comments' },
        { status: 500 }
      )
    }
  }
  
  export async function POST(request: Request) {
    try {
      const data = await request.json()
      const validation = validateCommentInput(data)
      
      if (!validation.success) {
        return NextResponse.json(
          { error: validation.error },
          { status: 400 }
        )
      }
  
      const comment = await db.comment.create({
        data: validation.data
      })
  
      return NextResponse.json(comment, { status: 201 })
    } catch (error) {
      return NextResponse.json(
        { error: 'Failed to create comment' },
        { status: 500 }
      )
    }
  }`,
      dependencies: ["db", "validateCommentInput"],
    },

    // Components
    {
      id: 7,
      name: "Navbar.tsx",
      category: "component",
      path: "components/",
      color: "#38A169",
      content: `// Navigation bar component
  'use client'
  
  import Link from 'next/link'
  import { usePathname } from 'next/navigation'
  import { Button } from './ui/Button'
  
  export function Navbar() {
    const pathname = usePathname()
    
    const links = [
      { href: '/', label: 'Home' },
      { href: '/blog', label: 'Blog' },
      { href: '/dashboard', label: 'Dashboard' }
    ]
  
    return (
      <nav className="bg-white shadow-sm">
        <div className="container mx-auto px-4 py-3 flex justify-between items-center">
          <Link href="/" className="text-xl font-bold">
            MyApp
          </Link>
          
          <div className="flex space-x-4">
            {links.map(link => (
              <Link
                key={link.href}
                href={link.href}
                className={\`px-3 py-2 rounded-md text-sm font-medium \${
                  pathname === link.href 
                    ? 'bg-blue-100 text-blue-700' 
                    : 'text-gray-700 hover:bg-gray-50'
                }\`}
              >
                {link.label}
              </Link>
            ))}
          </div>
          
          <Button href="/login">Sign in</Button>
        </div>
      </nav>
    )
  }`,
      dependencies: ["Button"],
    },
    {
      id: 8,
      name: "Footer.tsx",
      category: "component",
      path: "components/",
      color: "#38A169",
      content: `// Footer component
  export function Footer() {
    return (
      <footer className="bg-gray-100 mt-12 py-8">
        <div className="container mx-auto px-4 text-center text-gray-600">
          <p>Â© {new Date().getFullYear()} MyApp. All rights reserved.</p>
        </div>
      </footer>
    )
  }`,
      dependencies: [],
    },
    {
      id: 9,
      name: "Button.tsx",
      category: "component",
      path: "components/ui/",
      color: "#38A169",
      content: `// Button component
  'use client'
  
  import Link from 'next/link'
  import { cn } from '@/lib/utils'
  
  interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    href?: string
    variant?: 'primary' | 'secondary' | 'ghost'
  }
  
  export function Button({
    href,
    variant = 'primary',
    className,
    children,
    ...props
  }: ButtonProps) {
    const baseClasses = 'px-4 py-2 rounded-md font-medium transition-colors'
    
    const variantClasses = {
      primary: 'bg-blue-600 text-white hover:bg-blue-700',
      secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300',
      ghost: 'text-gray-700 hover:bg-gray-100'
    }
  
    if (href) {
      return (
        <Link
          href={href}
          className={cn(baseClasses, variantClasses[variant], className)}
        >
          {children}
        </Link>
      )
    }
  
    return (
      <button
        className={cn(baseClasses, variantClasses[variant], className)}
        {...props}
      >
        {children}
      </button>
    )
  }`,
      dependencies: ["cn"],
    },
    {
      id: 10,
      name: "Card.tsx",
      category: "component",
      path: "components/ui/",
      color: "#38A169",
      content: `// Card component
  import { cn } from '@/lib/utils'
  
  interface CardProps extends React.HTMLAttributes<HTMLDivElement> {}
  
  export function Card({ className, children, ...props }: CardProps) {
    return (
      <div
        className={cn(
          'bg-white rounded-lg shadow-md p-6 border border-gray-200',
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }`,
      dependencies: ["cn"],
    },
    {
      id: 11,
      name: "BlogList.tsx",
      category: "component",
      path: "components/blog/",
      color: "#38A169",
      content: `// Blog list component
  import Link from 'next/link'
  import { Card } from '../ui/Card'
  import { Button } from '../ui/Button'
  
  interface BlogListProps {
    posts: {
      id: string
      title: string
      excerpt: string
      slug: string
    }[]
  }
  
  export function BlogList({ posts }: BlogListProps) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {posts.map(post => (
          <Card key={post.id} className="flex flex-col">
            <h3 className="text-xl font-semibold mb-2">{post.title}</h3>
            <p className="text-gray-600 mb-4 flex-grow">{post.excerpt}</p>
            <Button
              href={\`/blog/\${post.slug}\`}
              className="self-start"
            >
              Read more
            </Button>
          </Card>
        ))}
      </div>
    )
  }`,
      dependencies: ["Card", "Button"],
    },
    {
      id: 12,
      name: "PostContent.tsx",
      category: "component",
      path: "components/blog/",
      color: "#38A169",
      content: `// Post content component
  import { formatDate } from '@/lib/formatters'
  
  interface PostContentProps {
    post: {
      title: string
      content: string
      publishedAt: Date
      author: {
        name: string
      }
    }
  }
  
  export function PostContent({ post }: PostContentProps) {
    return (
      <div>
        <h1 className="text-3xl font-bold mb-2">{post.title}</h1>
        <div className="text-gray-500 mb-6">
          Posted by {post.author.name} on {formatDate(post.publishedAt)}
        </div>
        <div 
          className="prose max-w-none"
          dangerouslySetInnerHTML={{ __html: post.content }}
        />
      </div>
    )
  }`,
      dependencies: ["formatDate"],
    },
    {
      id: 13,
      name: "CommentForm.tsx",
      category: "component",
      path: "components/blog/",
      color: "#38A169",
      content: `// Comment form component
  'use client'
  
  import { useState } from 'react'
  import { Button } from '../ui/Button'
  import { Input } from '../ui/Input'
  
  interface CommentFormProps {
    postId: string
  }
  
  export function CommentForm({ postId }: CommentFormProps) {
    const [content, setContent] = useState('')
    const [isSubmitting, setIsSubmitting] = useState(false)
    const [error, setError] = useState<string | null>(null)
  
    const handleSubmit = async (e: React.FormEvent) => {
      e.preventDefault()
      setIsSubmitting(true)
      setError(null)
  
      try {
        const response = await fetch('/api/comments', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            postId,
            content
          }),
        })
  
        if (!response.ok) {
          throw new Error('Failed to submit comment')
        }
  
        setContent('')
        // Optionally refresh comments
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Something went wrong')
      } finally {
        setIsSubmitting(false)
      }
    }
  
    return (
      <div className="mt-12">
        <h3 className="text-xl font-semibold mb-4">Leave a comment</h3>
        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="Your comment..."
            required
          />
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Submitting...' : 'Submit'}
          </Button>
          {error && <p className="text-red-500 text-sm">{error}</p>}
        </form>
      </div>
    )
  }`,
      dependencies: ["Button", "Input"],
    },

    // Hooks
    {
      id: 14,
      name: "useAuth.ts",
      category: "hook",
      path: "hooks/",
      color: "#805AD5",
      content: `// Authentication hook
  'use client'
  
  import { useEffect, useState } from 'react'
  import { useRouter } from 'next/navigation'
  import { User } from '@/types'
  
  export function useAuth() {
    const [user, setUser] = useState<User | null>(null)
    const [loading, setLoading] = useState(true)
    const router = useRouter()
  
    useEffect(() => {
      const fetchUser = async () => {
        try {
          const response = await fetch('/api/auth/me')
          if (!response.ok) {
            throw new Error('Not authenticated')
          }
          const data = await response.json()
          setUser(data)
        } catch (error) {
          setUser(null)
        } finally {
          setLoading(false)
        }
      }
  
      fetchUser()
    }, [])
  
    const login = async (email: string, password: string) => {
      try {
        const response = await fetch('/api/auth/login', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ email, password }),
        })
  
        if (!response.ok) {
          throw new Error('Login failed')
        }
  
        const data = await response.json()
        setUser(data)
        router.push('/dashboard')
      } catch (error) {
        throw error
      }
    }
  
    const logout = async () => {
      try {
        await fetch('/api/auth/logout', {
          method: 'POST',
        })
        setUser(null)
        router.push('/login')
      } catch (error) {
        console.error('Logout failed:', error)
      }
    }
  
    return { user, loading, login, logout }
  }`,
      dependencies: [],
    },

    // Utils
    {
      id: 15,
      name: "db.ts",
      category: "util",
      path: "lib/",
      color: "#E53E3E",
      content: `// Database client
  import { PrismaClient } from '@prisma/client'
  
  const globalForPrisma = globalThis as unknown as {
    prisma: PrismaClient | undefined
  }
  
  export const db = globalForPrisma.prisma ?? new PrismaClient()
  
  if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = db`,
      dependencies: [],
    },
    {
      id: 16,
      name: "api.ts",
      category: "util",
      path: "lib/",
      color: "#E53E3E",
      content: `// API utility functions
  export async function fetcher<T>(url: string): Promise<T> {
    const response = await fetch(url)
    if (!response.ok) {
      throw new Error('Failed to fetch data')
    }
    return response.json()
  }
  
  export async function postData<T>(url: string, data: any): Promise<T> {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    })
    if (!response.ok) {
      throw new Error('Failed to post data')
    }
    return response.json()
  }`,
      dependencies: [],
    },
    {
      id: 17,
      name: "formatters.ts",
      category: "util",
      path: "lib/",
      color: "#E53E3E",
      content: `// Date formatter
  export function formatDate(date: Date | string): string {
    const d = new Date(date)
    return d.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })
  }
  
  // Text truncation
  export function truncate(text: string, length: number): string {
    return text.length > length ? \`\${text.substring(0, length)}...\` : text
  }`,
      dependencies: [],
    },
    {
      id: 18,
      name: "utils.ts",
      category: "util",
      path: "lib/",
      color: "#E53E3E",
      content: `// Utility functions
  export function cn(...inputs: (string | undefined)[]) {
    return inputs.filter(Boolean).join(' ')
  }
  
  export function delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }`,
      dependencies: [],
    },
    {
      id: 19,
      name: "validators.ts",
      category: "util",
      path: "lib/",
      color: "#E53E3E",
      content: `// Input validators
  import { z } from 'zod'
  
  export const postSchema = z.object({
    title: z.string().min(1).max(100),
    content: z.string().min(1),
    authorId: z.string().min(1),
  })
  
  export const commentSchema = z.object({
    content: z.string().min(1).max(500),
    postId: z.string().min(1),
    authorId: z.string().min(1),
  })
  
  export function validatePostInput(data: unknown) {
    const result = postSchema.safeParse(data)
    return result
  }
  
  export function validateCommentInput(data: unknown) {
    const result = commentSchema.safeParse(data)
    return result
  }`,
      dependencies: [],
    },

    // Config files
    {
      id: 20,
      name: "next.config.js",
      category: "config",
      path: "/",
      color: "#718096",
      content: `/** @type {import('next').NextConfig} */
  const nextConfig = {
    experimental: {
      appDir: true,
    },
    images: {
      domains: ['images.unsplash.com'],
    },
  }
  
  module.exports = nextConfig`,
      dependencies: [],
    },
    {
      id: 21,
      name: "tailwind.config.js",
      category: "config",
      path: "/",
      color: "#718096",
      content: `/** @type {import('tailwindcss').Config} */
  module.exports = {
    content: [
      './app/**/*.{js,ts,jsx,tsx,mdx}',
      './components/**/*.{js,ts,jsx,tsx,mdx}',
    ],
    theme: {
      extend: {
        colors: {
          primary: {
            DEFAULT: '#3182CE',
            dark: '#2C5282',
          },
        },
      },
    },
    plugins: [],
  }`,
      dependencies: [],
    },
    {
      id: 22,
      name: "tsconfig.json",
      category: "config",
      path: "/",
      color: "#718096",
      content: `{
    "compilerOptions": {
      "target": "es5",
      "lib": ["dom", "dom.iterable", "esnext"],
      "allowJs": true,
      "skipLibCheck": true,
      "strict": true,
      "forceConsistentCasingInFileNames": true,
      "noEmit": true,
      "esModuleInterop": true,
      "module": "esnext",
      "moduleResolution": "node",
      "resolveJsonModule": true,
      "isolatedModules": true,
      "jsx": "preserve",
      "incremental": true,
      "baseUrl": ".",
      "paths": {
        "@/*": ["./*"]
      }
    },
    "include": ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"],
    "exclude": ["node_modules"]
  }`,
      dependencies: [],
    },

    // Global styles
    {
      id: 23,
      name: "globals.css",
      category: "styles",
      path: "app/",
      color: "#D53F8C",
      content: `/* Global styles */
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  
  :root {
    --foreground-rgb: 0, 0, 0;
    --background-rgb: 255, 255, 255;
  }
  
  @media (prefers-color-scheme: dark) {
    :root {
      --foreground-rgb: 255, 255, 255;
      --background-rgb: 0, 0, 0;
    }
  }
  
  body {
    color: rgb(var(--foreground-rgb));
    background: rgb(var(--background-rgb));
  }
  
  .prose {
    max-width: 65ch;
  }
  
  .prose img {
    border-radius: 0.5rem;
  }`,
      dependencies: [],
    },
  ],
  links: [
    // Root layout imports
    { source: 1, target: 7, relation: "imports" }, // layout -> Navbar
    { source: 1, target: 8, relation: "imports" }, // layout -> Footer
    { source: 1, target: 23, relation: "imports" }, // layout -> globals.css

    // Home page imports
    { source: 2, target: 9, relation: "imports" }, // page -> Button
    { source: 2, target: 10, relation: "imports" }, // page -> Card
    { source: 2, target: 16, relation: "uses" }, // page -> getFeaturedPosts (via api.ts)

    // Blog page imports
    { source: 3, target: 11, relation: "imports" }, // blog/page -> BlogList
    { source: 3, target: 16, relation: "uses" }, // blog/page -> getAllPosts (via api.ts)
    { source: 4, target: 12, relation: "imports" }, // blog/[slug]/page -> PostContent
    { source: 4, target: 13, relation: "imports" }, // blog/[slug]/page -> CommentForm
    { source: 4, target: 16, relation: "uses" }, // blog/[slug]/page -> getPostBySlug (via api.ts)

    // Component dependencies
    { source: 7, target: 9, relation: "imports" }, // Navbar -> Button
    { source: 11, target: 10, relation: "imports" }, // BlogList -> Card
    { source: 11, target: 9, relation: "imports" }, // BlogList -> Button
    { source: 12, target: 17, relation: "imports" }, // PostContent -> formatDate
    { source: 13, target: 9, relation: "imports" }, // CommentForm -> Button
    { source: 13, target: 16, relation: "uses" }, // CommentForm -> postData (via api.ts)

    // API route dependencies
    { source: 5, target: 15, relation: "imports" }, // posts/route -> db
    { source: 5, target: 19, relation: "imports" }, // posts/route -> validatePostInput
    { source: 6, target: 15, relation: "imports" }, // comments/route -> db
    { source: 6, target: 19, relation: "imports" }, // comments/route -> validateCommentInput

    // Utility imports
    { source: 9, target: 18, relation: "imports" }, // Button -> cn
    { source: 10, target: 18, relation: "imports" }, // Card -> cn

    // Style dependencies
    { source: 1, target: 21, relation: "configures" }, // layout -> tailwind.config.js
    { source: 23, target: 21, relation: "configures" }, // globals.css -> tailwind.config.js

    // TypeScript config
    { source: 1, target: 22, relation: "configures" }, // layout -> tsconfig.json
    { source: 2, target: 22, relation: "configures" }, // page -> tsconfig.json
    { source: 3, target: 22, relation: "configures" }, // blog/page -> tsconfig.json
    { source: 4, target: 22, relation: "configures" }, // blog/[slug]/page -> tsconfig.json
  ],
};

const ObsidianGraph = () => {
  const svgRef = useRef<SVGSVGElement>(null);
  const [graphData, setGraphData] = useState<GraphData>(initialGraphData);
  const [selectedNode, setSelectedNode] = useState<Node | null>(null);
  const [selectedFile, setSelectedFile] = useState<Node | null>(null);
  const [connectedNodes, setConnectedNodes] = useState<Node[]>([]);
  const [categoryFilters, setCategoryFilters] = useState<{
    [key: string]: boolean;
  }>({
    page: true,
    layout: true,
    component: true,
    api: true,
    hook: true,
    util: true,
    config: true,
    styles: true,
    types: true,
    loading: true,
    error: true,
  });
  const [searchTerm, setSearchTerm] = useState("");

  // Filter nodes based on category and search term
  const getFilteredNodes = () => {
    return graphData.nodes.filter(
      (node) =>
        categoryFilters[node.category] &&
        (searchTerm === "" ||
          node.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          (node.path &&
            node.path.toLowerCase().includes(searchTerm.toLowerCase())))
    );
  };

  // Get filtered links based on visible nodes
  const getFilteredLinks = () => {
    const filteredNodes = getFilteredNodes();
    const nodeIds = new Set(filteredNodes.map((node) => node.id));

    return graphData.links.filter(
      (link) =>
        nodeIds.has(
          typeof link.source === "object"
            ? (link.source as any).id
            : link.source
        ) &&
        nodeIds.has(
          typeof link.target === "object"
            ? (link.target as any).id
            : link.target
        )
    );
  };

  // Find connected nodes when a node is selected
  useEffect(() => {
    if (!selectedNode) {
      setConnectedNodes([]);
      return;
    }

    const filteredLinks = getFilteredLinks();
    const connectedNodeIds = new Set<number>();

    filteredLinks.forEach((link) => {
      const sourceId =
        typeof link.source === "object" ? (link.source as any).id : link.source;
      const targetId =
        typeof link.target === "object" ? (link.target as any).id : link.target;

      if (sourceId === selectedNode.id) connectedNodeIds.add(targetId);
      if (targetId === selectedNode.id) connectedNodeIds.add(sourceId);
    });

    const connected = graphData.nodes.filter((node) =>
      connectedNodeIds.has(node.id)
    );
    setConnectedNodes(connected);
  }, [selectedNode, graphData]);

  // Render the graph visualization
  useEffect(() => {
    if (!svgRef.current) return;

    // Clear previous rendering
    d3.select(svgRef.current).selectAll("*").remove();

    const svg = d3.select(svgRef.current);
    const container = svg.append("g");
    const width = svgRef.current.clientWidth;
    const height = svgRef.current.clientHeight;

    svg
      .attr("width", width)
      .attr("height", height)
      .style("background", "#1e1e2e");

    // Add zoom functionality
    const zoom = d3
      .zoom()
      .scaleExtent([0.1, 4])
      .on("zoom", (event) => {
        container.attr("transform", event.transform);
      });

    svg.call(zoom as any);

    // Initial zoom to fit the graph
    svg.call(
      zoom.transform as any,
      d3.zoomIdentity.translate(width / 2, height / 2).scale(0.8)
    );

    const filteredNodes = getFilteredNodes();
    const filteredLinks = getFilteredLinks();

    // Create a simulation with nodes and links
    const simulation = d3
      .forceSimulation(filteredNodes)
      .force("charge", d3.forceManyBody().strength(-300))
      .force("center", d3.forceCenter(0, 0))
      .force(
        "link",
        d3
          .forceLink(filteredLinks)
          .id((d: any) => d.id)
          .distance((d) => {
            // Adjust distance based on node types
            const source =
              typeof d.source === "object"
                ? d.source
                : filteredNodes.find((n) => n.id === d.source);
            const target =
              typeof d.target === "object"
                ? d.target
                : filteredNodes.find((n) => n.id === d.target);

            if (source?.category === "config" || target?.category === "config")
              return 180;
            if (source?.category === "types" || target?.category === "types")
              return 150;
            return 120;
          })
      )
      .force("x", d3.forceX().strength(0.05))
      .force("y", d3.forceY().strength(0.05))
      .force("collision", d3.forceCollide().radius(30))
      .alphaDecay(0.01);

    // Create curved links
    const link = container
      .append("g")
      .attr("class", "links")
      .selectAll("path")
      .data(filteredLinks)
      .enter()
      .append("path")
      .attr("class", "link")
      .attr("stroke", "#58A6FF")
      .attr("stroke-width", 0.8)
      .attr("fill", "none")
      .style("opacity", 0.2)
      .attr("marker-end", "url(#arrowhead)");

    // Create arrowhead marker
    svg
      .append("defs")
      .append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 20)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "#58A6FF");

    // Create nodes
    const node = container
      .append("g")
      .attr("class", "nodes")
      .selectAll(".node")
      .data(filteredNodes)
      .enter()
      .append("g")
      .attr("class", "node")
      .call(drag(simulation) as any)
      .on("click", (event, d: any) => {
        event.stopPropagation();
        const clickedNode = graphData.nodes.find((n) => n.id === d.id) || null;
        setSelectedNode(clickedNode === selectedNode ? null : clickedNode);
        setSelectedFile(null);
      });

    // Add circles to nodes
    node
      .append("circle")
      .attr("r", (d: any) => {
        // Size based on node type
        switch (d.category) {
          case "page":
          case "layout":
            return 8;
          case "component":
            return 7;
          case "api":
            return 8;
          case "config":
            return 9;
          default:
            return 6;
        }
      })
      .attr("fill", (d: any) => d.color || "#C9D1D9")
      .attr("stroke", (d: any) =>
        selectedNode?.id === d.id ? "#fff" : "#1e1e2e"
      )
      .attr("stroke-width", (d: any) => (selectedNode?.id === d.id ? 2 : 1.5));

    // Add labels to nodes
    node
      .append("text")
      .attr("dx", 10)
      .attr("dy", ".35em")
      .text((d: any) => {
        // Show path for better context
        if (d.path && d.path !== "/") {
          return `${d.path}${d.name}`;
        }
        return d.name;
      })
      .attr("fill", "#C9D1D9")
      .style("font-size", "10px")
      .style("pointer-events", "none");

    // Highlight connected nodes when selected
    if (selectedNode) {
      node.classed(
        "highlighted",
        (n: any) =>
          n.id === selectedNode.id ||
          connectedNodes.some((cn) => cn.id === n.id)
      );
      node.classed(
        "faded",
        (n: any) =>
          n.id !== selectedNode.id &&
          !connectedNodes.some((cn) => cn.id === n.id)
      );

      link.classed("highlighted", (l: any) => {
        const sourceId = typeof l.source === "object" ? l.source.id : l.source;
        const targetId = typeof l.target === "object" ? l.target.id : l.target;
        return sourceId === selectedNode.id || targetId === selectedNode.id;
      });
      link.classed("faded", (l: any) => {
        const sourceId = typeof l.source === "object" ? l.source.id : l.source;
        const targetId = typeof l.target === "object" ? l.target.id : l.target;
        return sourceId !== selectedNode.id && targetId !== selectedNode.id;
      });
    }

    function ticked() {
      // Update link positions with curved paths
      link.attr("d", (d: any) => {
        const sourceX = d.source.x;
        const sourceY = d.source.y;
        const targetX = d.target.x;
        const targetY = d.target.y;

        // Check if there are multiple links between these nodes
        const multipleLinks = filteredLinks.filter((l) => {
          const s1 =
            typeof l.source === "object" ? (l.source as any).id : l.source;
          const t1 =
            typeof l.target === "object" ? (l.target as any).id : l.target;
          const s2 = typeof d.source === "object" ? d.source.id : d.source;
          const t2 = typeof d.target === "object" ? d.target.id : d.target;

          return (s1 === s2 && t1 === t2) || (s1 === t2 && t1 === s2);
        });

        if (multipleLinks.length > 1) {
          // Create a curved path
          const dx = targetX - sourceX;
          const dy = targetY - sourceY;
          const dr =
            Math.sqrt(dx * dx + dy * dy) * (1 + multipleLinks.indexOf(d) * 0.3);
          const sweep = 1;
          return `M${sourceX},${sourceY}A${dr},${dr} 0 0,${sweep} ${targetX},${targetY}`;
        } else {
          // Straight line for single links
          return `M${sourceX},${sourceY}L${targetX},${targetY}`;
        }
      });

      // Update node positions
      node.attr("transform", (d: any) => `translate(${d.x},${d.y})`);
    }

    // Implement drag behavior
    function drag(simulation: any) {
      return d3
        .drag()
        .on("start", (event: any, d: any) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on("drag", (event: any, d: any) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on("end", (event: any, d: any) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        });
    }

    // Run the simulation
    simulation.on("tick", ticked);

    // Cleanup function
    return () => {
      simulation.stop();
    };
  }, [graphData, selectedNode, connectedNodes, categoryFilters, searchTerm]);

  // Toggle category filter
  const toggleCategoryFilter = (category: string) => {
    setCategoryFilters((prev) => ({
      ...prev,
      [category]: !prev[category],
    }));
  };

  // Get color for category button
  const getCategoryColor = (category: string) => {
    const colorMap: { [key: string]: string } = {
      page: "bg-blue-600",
      layout: "bg-blue-700",
      component: "bg-green-600",
      api: "bg-orange-600",
      hook: "bg-purple-600",
      util: "bg-red-600",
      config: "bg-gray-600",
      styles: "bg-pink-600",
      types: "bg-yellow-600",
      loading: "bg-blue-500",
      error: "bg-red-500",
    };

    return categoryFilters[category]
      ? colorMap[category] || "bg-gray-600"
      : "bg-gray-700";
  };

  // Handle file selection from connected nodes
  const handleFileSelect = (node: Node) => {
    setSelectedFile(node);
  };

  return (
    <div className="flex flex-col h-screen bg-[#1e1e2e] text-gray-200">
      {/* Header */}
      <header className="p-4 bg-gray-900 w-full">
        <h1 className="text-2xl font-bold text-white">
          Next.js Project Structure Explorer
        </h1>
        <div className="flex flex-col md:flex-row justify-between items-center mt-2 gap-3">
          <div className="flex flex-wrap gap-2">
            {["page", "layout", "component", "api", "hook"].map((category) => (
              <button
                key={category}
                onClick={() => toggleCategoryFilter(category)}
                className={`px-3 py-1 rounded text-xs ${getCategoryColor(
                  category
                )}`}
              >
                {category.charAt(0).toUpperCase() + category.slice(1)}
              </button>
            ))}
          </div>
          <div className="relative w-full md:w-64">
            <input
              type="text"
              placeholder="Search files..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="px-4 py-2 bg-gray-800 text-white rounded border border-gray-700 w-full"
            />
            {searchTerm && (
              <button
                onClick={() => setSearchTerm("")}
                className="absolute right-2 top-2 text-gray-400 hover:text-white"
              >
                â
              </button>
            )}
          </div>
        </div>
      </header>

      <div className="flex flex-1 overflow-hidden flex-col md:flex-row">
        {/* File System Panel */}
        <div className="md:w-1/4 w-full bg-gray-800 border-r border-gray-700 overflow-y-auto p-4">
          <h2 className="font-semibold mb-4">Project Files</h2>
          {selectedNode ? (
            <>
              <div className="mb-4 p-3 bg-gray-700 rounded">
                <h3 className="font-medium">{selectedNode.name}</h3>
                <div className="text-xs text-gray-400 mt-1">
                  {selectedNode.category}
                </div>
              </div>
              <h3 className="font-medium mb-2">Connected Files:</h3>
              <div className="space-y-2">
                {connectedNodes.map((node) => (
                  <div
                    key={node.id}
                    onClick={() => handleFileSelect(node)}
                    className={`p-2 rounded cursor-pointer hover:bg-gray-700 ${
                      selectedFile?.id === node.id ? "bg-gray-700" : ""
                    }`}
                  >
                    <div className="font-medium">{node.name}</div>
                    <div className="text-xs text-gray-400">{node.category}</div>
                  </div>
                ))}
              </div>
            </>
          ) : (
            <div className="text-gray-400 italic">
              Click on a node to see connected files
            </div>
          )}
        </div>

        {/* Code Explanation Panel */}
        <div className="md:w-1/3 w-full bg-gray-900 border-r border-gray-700 overflow-y-auto p-4">
          {selectedFile ? (
            <>
              <div className="flex justify-between items-center mb-4">
                <h2 className="font-semibold">{selectedFile.name}</h2>
                <button
                  onClick={() => setSelectedFile(null)}
                  className="text-gray-400 hover:text-white"
                >
                  â
                </button>
              </div>
              <div className="bg-gray-800 p-4 rounded font-mono text-sm whitespace-pre overflow-x-auto">
                {selectedFile.content}
              </div>
            </>
          ) : (
            <div className="text-gray-400 italic">
              Select a file to view its content
            </div>
          )}
        </div>

        {/* Graph Visualization Panel */}
        <div className="flex-1 bg-[#1e1e2e] overflow-hidden h-[300px] md:h-auto">
          <svg ref={svgRef} className="w-full h-full"></svg>
        </div>
      </div>
    </div>
  );
};

export default ObsidianGraph;
